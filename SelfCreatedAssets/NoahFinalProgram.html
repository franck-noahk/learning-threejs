<!DOCTYPE html>

<html>

<head>
    <title> Example 01.01 - Basic skeleton </title>
    <script src="https://student-noah-franck.000webhostapp.com/libs/three.js">
    </script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>

<body>
    <!--Div which would hold Output -->
    <div id="output">
    </div>
    <!-- Javascript code that runs our Three.js examples -->
    <script>
        //-------------------------- Declaring scenes -------------------------------------
        var cubesScene = new THREE.Scene();
        var gameScene = new THREE.Scene(); //1
        var wolfScene = new THREE.Scene(); //2
        var spaceScene = new THREE.Scene(); //3
        var sphereScene = new THREE.Scene(); //4
        var monkeyScene = new THREE.Scene(); //5
        var helecopterScene = new THREE.Scene(); //6
        var jailScene = new THREE.Scene(); //7
        var deathStar = new THREE.Scene() //8
        //---------------------------Render--------------------------------------------
        var renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(new THREE.Color(0xffffff));
        //--------------------------camera ------------------------------------------------------
        var universalCamera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 3000);
        //-------------------------lights---------------------------------------------
        var ambientLight = new THREE.AmbientLight(new THREE.Color(0x222222));
        var spotlight1 = new THREE.SpotLight(new THREE.Color(0xffffff));
        var spotlight1 = new THREE.SpotLight(new THREE.Color(0xffffff));
        var spotlight1 = new THREE.SpotLight(new THREE.Color(0xffffff));
        //------------------------models--------------------------------------------------------------------
        //----------------------------cubes
        var cubes = [];

        function cubeCreate(x, y, z, hex, scene) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.hex = hex
            var cubeSize = 20;
            var cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
            this.object = new THREE.Mesh(new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize), new THREE.MeshBasicMaterial({
                color: Math.random() * 0xffffff
            }));
            //lesson learned, one must do this.object = new THREE.Mesh() and define eveything inside of the () for the geometry and the material
            this.object.position.set(x, y, z);
            //this.object.name = "cube-" + scene.children.length;
            /*
                  this.object.positionX = x;
                  this.object.positionY = y;
                  this.object.positionZ = z;
                  // add the cube to the scene
                  */
            cubes.push(this.object);
            cubesScene.add(this.object);
        };
        var cube = new cubeCreate(10, 10, 0, 0x12ac47, cubesScene); // back top right
        var cube1 = new cubeCreate(10, 10, 20, 0xaaaaaa, cubesScene); //front top Right
        var cube2 = new cubeCreate(10, -10, 0, 0x557327, cubesScene); //back bottom right
        var cube3 = new cubeCreate(10, -10, 20, 0x81740a, cubesScene); //front bottom right
        var cube4 = new cubeCreate(-10, -10, 20, 0x0000ff, cubesScene); //front bottom left
        var cube5 = new cubeCreate(-10, 10, 20, 0x990033, cubesScene); //front top Left
        var cube6 = new cubeCreate(-10, -10, 0, 0x83ffd3, cubesScene); //back bottom left
        var cube7 = new cubeCreate(-10, 10, 0, 0x5813af, cubesScene); //back left top


        //-------------------------------saturn
        var saturnSphereGeometry = new THREE.SphereGeometry(10, 30, 30);
        saturnSphereGeometry.vertices.forEach(function (v) {
            if (v.y > -.1 && v.y <= .1) {
                v.x *= 1.5;
                v.y *= 1.5;
                v.z *= 1.5;
            }
        })
        var saturnSphere = new THREE.Mesh(saturnSphereGeometry, new THREE.MeshLambertMaterial({ shading: THREE.FlatShading, color: 0x2299ff }));
        sphereScene.add(saturnSphere);
        //------------------------------helecopter
        var body = new THREE.Mesh(new THREE.BoxGeometry(45, 55, 40, 5), new THREE.MeshLambertMaterial({
            color: 0x6960Ec
        }));
        body.position.set(0, 27.5, 0)
        helecopterScene.add(body);
        var cockpit = new THREE.Mesh(new THREE.BoxGeometry(30, 27.5, 40, 5), new THREE.MeshLambertMaterial({
            color: 0x6960Ec,
        }));
        cockpit.position.set(-37.5, -13.8, 0);
        body.add(cockpit);
        var connector = new THREE.Mesh(new THREE.CylinderGeometry(5, 5, 7, 10, 10), new THREE.MeshLambertMaterial({
            color: 0x6960Ec
        }));
        connector.position.set(0, 30, 0);
        body.add(connector);
        var tail = new THREE.Mesh(new THREE.CylinderGeometry(15, 5, 55, 6, 6), new THREE.MeshLambertMaterial({
            color: 0x6960Ec
        }));
        tail.position.set(37.5, 0, 0);
        tail.rotateZ(-4.75);
        body.add(tail);
        var rearProppeller = new THREE.Mesh(new THREE.SphereGeometry(15, 10, 10), new THREE.MeshLambertMaterial({
            side: THREE.DoubleSide,
        }));
        rearProppeller.scale.y = .05;
        rearProppeller.scale.z = .1;
        rearProppeller.position.set(0, -20, 8.5)
        tail.add(rearProppeller);
        var Wilms = new THREE.Mesh(new THREE.SphereGeometry(6, 5, 5), new THREE.MeshLambertMaterial({
            color: 'red'
        }));
        Wilms.position.set(0, 18, 0);
        cockpit.add(Wilms);
        var blades = new THREE.Mesh(new THREE.SphereGeometry(125, 5, 5), new THREE.MeshLambertMaterial({
            side: THREE.DoubleSide,
            color: 'black'
        }));
        blades.rotateX(.5 * Math.PI);
        blades.scale.y = .05;
        blades.scale.z = .01;
        blades.position.set(0, 2.5, 0);
        connector.add(blades);
        var vertices = [
            new THREE.Vector3(0, 27.5, 20.1), //0
            new THREE.Vector3(0, 55, 20.1), //1
            new THREE.Vector3(-30, 27.5, 20.1), //2
            new THREE.Vector3(0, 27.5, -20.1), //3
            new THREE.Vector3(0, 55, -20.1), //4
            new THREE.Vector3(-30, 27.5, -20.1) //5
        ];
        var faces = [
            new THREE.Face3(0, 1, 2),
            new THREE.Face3(3, 4, 5),
            new THREE.Face3(5, 2, 1),
            new THREE.Face3(1, 5, 4),
        ];

        var triangleGeom = new THREE.Geometry();
        triangleGeom.vertices = vertices;
        triangleGeom.faces = faces;
        triangleGeom.computeFaceNormals();

        var triangle = new THREE.Mesh(triangleGeom, new THREE.MeshLambertMaterial({
            side: THREE.DoubleSide,
            transparent: true,
            opacity: .60
        }));
        triangle.position.set(-22.5, -27.5, 0);
        body.add(triangle);

        var sphereGeom = new THREE.SphereGeometry(10, 10, 10);
        sphereGeom.faces.forEach(
            /*
            function(f){
              if (f.y > -0.1 && v.y < 0.1){
                f.x *= 1.6;
                f.y *= 1.6;
                f.z *= 1.6;
              */

            function (f) {
                if (sphereGeom.vertices[f.c].y > 0) {
                    f.color.setRGB(9, 0, 0);
                }
                if (sphereGeom.vertices[f.c].y < 0) {
                    f.color.setRGB(0, 0, 9);
                }
            }

        );
        var sphereMaterial = new THREE.MeshLambertMaterial({
            shading: THREE.FlatShading,
            //color: 0xcccccc,
        });
        sphereMaterial.vertexColors = THREE.FaceColors;
        var sphere = new THREE.Mesh(sphereGeom, sphereMaterial);
        sphereScene.add(sphere);




        //------------------------normal functions- -----------------------------------------------




        //------------------------renderscenes funcitons-------------------------------------------
        var topPropellerAccelerating, topPropellerDecelerating, backPropellerLeft, backPropellerRight;
        topPropellerAccelerating = topPropellerDecelerating = backPropellerLeft = backPropellerRight = false;
        var bladesCounter = 0;
        var backbladesCounter = 0;
        var neutralPropeller = false;
        var stationaryHeight = true;
        var renderSceneVariable = 0;
        //--------------------------------Functions--------------------------------
        function renderScene() {
            if (renderSceneVariable == 0)
                expandingCubeRenderScene();
            else if (renderSceneVariable == 1)
                HelecopterRenderScene();
            else if (renderSceneVariable == 2)

            else if (renderSceneVariable == 3)
            
            else if (renderSceneVariable == 4)
                saturnRenderScene();
            else if (renderSceneVariable == 5)
            
            else if (renderSceneVariable == 6)
            
            else if (renderSceneVariable == 7)

            else if (renderSceneVariable == 8)


                function HelecopterRenderScene() {
                    //console.log(bladesCounter);
                    //bladesCounter logic
                    console.log("blades counter : " + bladesCounter);
                    if (topPropellerAccelerating == true) {
                        if (bladesCounter < 300) {
                            bladesCounter = bladesCounter + 1;
                        }
                    } else if (topPropellerDecelerating == true) {
                        if (bladesCounter > 0) {
                            bladesCounter = bladesCounter - 1;
                        }
                    }
                    //speed of the blades
                    /*
                    if (bladesCounter > 0) {
                        blades.rotateZ(bladesCounter / 3000);
                    }else if(bladesCounter == 300 || bladesCounter == -500) {
                        blades.rotateZ(bladesCounter / 2500);
                    }else if (topPropellerDecelerating == true && body.position.y > 30) {
                        blades.rotateZ(bladesCounter / 3500);
                    }
                    */

                    if (topPropellerAccelerating == true) {
                        console.log("propeller speed: " + bladesCounter);
                        if (bladesCounter < 50)
                            blades.rotateZ(.1);
                        if (bladesCounter < 100 && bladesCounter >= 50)
                            blades.rotateZ(1.5);
                        if (bladesCounter < 200 && bladesCounter >= 100)
                            blades.rotateZ(2);
                        if (bladesCounter >= 200)
                            blades.rotateZ(2.5);
                    }

                    if (topPropellerDecelerating == true) {
                        console.log("propeller speed: " + bladesCounter);
                        if (bladesCounter < 50 && bladesCounter != 0) {
                            blades.rotateZ(.1);
                            backPropellerLeft = backPropellerRight = false;
                        }
                        if (bladesCounter < 100 && bladesCounter >= 50) {
                            blades.rotateZ(1.5);
                            backPropellerLeft = backPropellerRight = false;
                        }
                        if (bladesCounter < 200 && bladesCounter >= 100)
                            blades.rotateZ(2);
                        if (bladesCounter >= 200)
                            blades.rotateZ(2.5);
                    }


                    if (bladesCounter > 100 && body.position.y < 125) {
                        body.position.y = body.position.y + .5;
                    }
                    if (stationaryHeight == false && topPropellerDecelerating == true && body.position.y > 30) {
                        body.position.y = body.position.y - 1
                    } else if (stationaryHeight == true) {
                        body.position.y;
                    }

                    if (backPropellerLeft == true) {
                        if (backbladesCounter < 500) {
                            backbladesCounter = backbladesCounter + 1;
                        }
                        rearProppeller.rotateZ(backbladesCounter / 1000);
                    } else if (backPropellerRight == true) {
                        if (backbladesCounter > -500) {
                            backbladesCounter = backbladesCounter - 1;
                        }
                        rearProppeller.rotateZ(backbladesCounter / 1000);
                    }
                    if (backbladesCounter % 500) {
                        scene.rotateY(backbladesCounter / 3000);
                    } else if (backbladesCounter == 500 || backbladesCounter == -500) {
                        scene.rotateY(backbladesCounter / 3000);
                    }
                    if (neutralPropeller == true || backPropellerLeft == false && backPropellerRight == false) {
                        if (backbladesCounter < 0) {
                            backbladesCounter += 10;
                        }
                        if (backbladesCounter > 0) {
                            backbladesCounter -= 10;
                        }
                        if (backbladesCounter == 0) {
                            neutralPropeller == false;
                        }
                    }

                    rearProppeller.rotateZ(.01);

                    renderer.render(helecopterScene, universalCamera);
                    requestAnimationFrame(renderScene);

                    function onKeyDown(event) {
                        //console.log(event.which);
                        switch (event.which) {
                            case 38: //up
                                stationaryHeight = false;
                                topPropellerAccelerating = true;
                                topPropellerDecelerating = false;
                                break;
                            case 40: //down
                                stationaryHeight = false;
                                topPropellerAccelerating = false;
                                topPropellerDecelerating = true;
                                break;
                            case 37: //left
                                if (body.position.y > 30) {
                                    backPropellerRight = false;
                                    neutralPropeller = false;
                                    backPropellerLeft = true;
                                }
                                break;
                            case 39: //right
                                if (body.position.y > 30) {
                                    backPropellerLeft = false;
                                    neutralPropeller = false;
                                    backPropellerRight = true;
                                }
                                break;
                            case 32: //space
                                //TODO:first space is stop rotating second space is stop the altitude.
                                backPropellerRight = false;
                                backPropellerLeft = false;
                                neutralPropeller = true;
                                break;
                        }
                    }


                }


            function expandingCubeRenderScene() {

                cubesScene.rotateY(.01);
                cubesScene.rotateX(.01);

                myTimer += 1;
                //console.log(myTimer);

                if (myTimer > 500 && myTimer < 1000) {
                    /*
                    Goal of this is to have the cubes seporate into different pieces along the diagional plane and then come back together over time.
                    */

                    cube.object.position.y += .1;
                    cube.object.position.x += .1;
                    cube.object.position.z += -.1;

                    cube1.object.position.y += .1;
                    cube1.object.position.x += .1;
                    cube1.object.position.z += .1;

                    cube2.object.position.y += -.1;
                    cube2.object.position.x += .1;
                    cube2.object.position.z += -.1;

                    cube3.object.position.y += -.1;
                    cube3.object.position.x += .1;
                    cube3.object.position.z += .1;

                    cube4.object.position.y += -.1;
                    cube4.object.position.x += -.1;
                    cube4.object.position.z += .1;

                    cube5.object.position.y += .1;
                    cube5.object.position.x += -.1;
                    cube5.object.position.z += .1;

                    cube6.object.position.y += -.1;
                    cube6.object.position.x += -.1;
                    cube6.object.position.z += -.1;

                    cube7.object.position.y += .1;
                    cube7.object.position.x += -.1;
                    cube7.object.position.z += -.1;

                } else if (myTimer >= 1000 && myTimer < 1500) {
                    cube.object.position.y += -.1;
                    cube.object.position.x += -.1;
                    cube.object.position.z += .1;

                    cube1.object.position.y += -.1;
                    cube1.object.position.x += -.1;
                    cube1.object.position.z += -.1;

                    cube2.object.position.y += .1;
                    cube2.object.position.x += -.1;
                    cube2.object.position.z += .1;

                    cube3.object.position.y += .1;
                    cube3.object.position.x += -.1;
                    cube3.object.position.z += -.1;

                    cube4.object.position.y += .1;
                    cube4.object.position.x += .1;
                    cube4.object.position.z += -.1;

                    cube5.object.position.y += -.1;
                    cube5.object.position.x += .1;
                    cube5.object.position.z += -.1;

                    cube6.object.position.y += .1;
                    cube6.object.position.x += .1;
                    cube6.object.position.z += .1;

                    cube7.object.position.y += -.1;
                    cube7.object.position.x += .1;
                    cube7.object.position.z += .1;

                } else if (myTimer >= 1500) {
                    myTimer = 0;

                    cube.object.position.set(10, 10, 0);
                    cube1.object.position.set(10, 10, 20);
                    cube2.object.position.set(10, -10, 0);
                    cube3.object.position.set(10, -10, 20);
                    cube4.object.position.set(-10, -10, 20);
                    cube5.object.position.set(-10, 10, 20);
                    cube6.object.position.set(-10, -10, 0);
                    cube7.object.position.set(-10, 10, 0);

                }

                renderer.render(cubesScene, camera);
                requestAnimationFrame(renderScene);
            }

            function saturnRenderScene() {
                renderer.render(sphereScene, universalCamera);
                function onKeyDown(event) {
                    //              console.log(event.which);
                    switch (event.which) {
                        case 39: sphere.rotateY(0.04); break;    // angleY += 0.01
                        case 37: sphere.rotateY(-0.04); break;       // angleY -= 0.01
                        case 40: sphere.rotateX(0.04); break;
                        case 38: sphere.rotateX(-0.04);
                    }
                }
                requestAnimationFrame(renderScene);
            }

            //Function for  removing cubes. 
            //might nees to remove it to the 
            document.onmousedown = function (event) {
                //console.log(event);
                var vector = new THREE.Vector3(event.clientX / window.innerWidth * 2 - 1, -event.clientY / window.innerHeight *
                    2 + 1, 0.5);
                //magic step
                vector = vector.unproject(camera); //using the prjection matrix to unproject the click and throw it into 3d space
                console.log("unprojected vector: ", vector)
                var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());
                var intersects = raycaster.intersectObjects(cubes);
                if (intersects.length > 0) {
                    var intersectedObjIndex = cubes.indexOf(intersects[0].object);
                    scene.remove(intersects[0].object);
                    cubes.splice(intersectedObjIndex, 1);
                    //directions.splice(intersectedObjIndex);
                    //totalCubes = totalCubes - 1;
                }
            }


            window.addEventListener('keydown', onKeyDown, false);
            document.getElementById("output").appendChild(renderer.domElement);
        }
        function onResize() {
            myCamera.aspect = window.innerWidth / window.innerHeight;
            myCamera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        window.addEventListener('resize', onResize, false);
    </script>
</body>
<html>